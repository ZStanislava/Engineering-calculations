# -*- coding: utf-8 -*-
"""2 лаба вычислительный конечный вариант.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AAyHRT7LZqXTP0Qvx62Xx5rjEloCK9ad
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from math import log
from math import cos, sin,atan,sqrt

c = (0.4, 7.8, 0.9)
p = (3.1, 0.7, 2)
q = (1, 2, 1.5)

# A, B, C - коэффиценты из прошлой лабы
def A(X, j, p, q):
    return q*(X[j]-X[j-1])/6 - p/(X[j]-X[j-1])

def B(X, j, p, q, side='m'):
    if side == 'm':
        return p/(X[j]-X[j-1]) + p/(X[j+1]-X[j]) + q/3 * (X[j+1] - X[j-1])
    elif side == 'l':
        return p/(X[j]-X[j-1]) + q/3*(X[j]-X[j-1])
    elif side == 'r':
        return p/(X[j+1]-X[j]) + q/3*(X[j+1]-X[j])

def C(X, j, p, q):
    return q*(X[j+1]-X[j])/6 - p/(X[j+1]-X[j])

# Коэффициенты из этой лабы
def A1(A, X, j, tau, c, p, q):
    return c*(X[j]-X[j-1])/6 + tau/2 * A(X, j, p, q)

def A2(B, X, j, tau, c, p, q, side='m'):
    if side == 'm':
        return c/3 * (X[j+1] - X[j-1]) + tau/2 * B(X, j, p, q)
    elif side == 'l':
        return c/3 * (X[j] - X[j-1]) + tau/2 * B(X, j, p, q, 'l')
    elif side == 'r':
        return c/3 * (X[j+1] - X[j]) + tau/2 * B(X, j, p, q, 'r')

def A3(C, X, j, tau, c, p, q):
    return c*(X[j+1]-X[j])/6 + tau/2 * C(X, j, p, q)

# F11, F22, F33 - функции из прошлой лабы
def F11_left(X, j):
    return (1/(X[j]-X[j-1]))*((2*( X[j-1]+2)**2*log(X[j-1]+2)- X[j-1]*(3* X[j-1]+4*(( X[j]+2)*log(X[j]+2)- X[j])+4)+2*( X[j]-2)*( X[j]+2)*log(X[j]+2)-( X[j]-4)* X[j])/4)
def F11_right(X, j):
    return (1/(X[j+1]-X[j]))* ((2*( X[j]+2)*( X[j]-2* X[j+1]-2)*log(X[j]+2)- X[j]*( X[j]-4* X[j+1]-4)+2*( X[j+1]+2)**2*log(X[j+1]+2)- X[j+1]*(3* X[j+1]+4))/4)
def F33_left(X, j):
    return (1/(X[j]-X[j-1]))*((2*( X[j-1]+1)**2*log(X[j-1]+1)- X[j-1]*(3* X[j-1]+4*(( X[j]+1)*log(X[j]+1)- X[j])+2)+2*( X[j]-1)*( X[j]+1)*log(X[j]+1)-( X[j]-2)* X[j])/4)
def F33_right(X, j):
    return (1/(X[j+1]-X[j]))*((2*( X[j]+1)**2*log(X[j]+1)- X[j]*(3* X[j]+4*(( X[j+1]+1)*log(X[j+1]+1)- X[j+1])+2)+2*( X[j+1]-1)*( X[j+1]+1)*log(X[j+1]+1)-( X[j+1]-2)* X[j+1])/4)
def F22_left(X, j):
    return 20*((1/(X[j]-X[j-1]))*((2*( X[j-1]+2)**2*log(X[j-1]+2)- X[j-1]*(3* X[j-1]+4*(( X[j]+2)*log(X[j]+2)- X[j])+4)+2*( X[j]-2)*( X[j]+2)*log(X[j]+2)-( X[j]-4)* X[j])/4))
def F22_right(X, j):
    return 20*((1/(X[j+1]-X[j]))* ((2*( X[j]+2)*( X[j]-2* X[j+1]-2)*log(X[j]+2)- X[j]*( X[j]-4* X[j+1]-4)+2*( X[j+1]+2)**2*log(X[j+1]+2)- X[j+1]*(3* X[j+1]+4))/4))

# Функции из этой лабы
def F1_right(X, j, t):
    return (-(sin(4* X[j+1])-4*cos(4* X[j])*( X[j+1]- X[j])-sin(4* X[j]))/16)/ ((X[j+1] - X[j])*(1/(1+t**2)))
def F1_left(X, j, t):
    return ((sin(4* X[j])+(4* X[j-1]-4* X[j])*cos(4* X[j])-sin(4* X[j-1]))/16) / ((X[j] - X[j-1]) *(1/(1+t**2)))
def F2_left(X, j, t):
    return (-(2* X[j-1]*log(abs(X[j]*( X[j]+sqrt(2))+1))-2* X[j-1]*log(abs(X[j]*( X[j]-sqrt(2))+1))+(4* X[j-1]+2**(5/2))*atan(sqrt(2)* X[j]+1)+(4* X[j-1]-2**(5/2))*atan(sqrt(2)* X[j]-1)-2* X[j-1]*log(abs(X[j-1]*( X[j-1]+sqrt(2))+1))+2* X[j-1]*log(abs(X[j-1]*( X[j-1]-sqrt(2))+1))-(4* X[j-1]+2**(5/2))*atan(sqrt(2)* X[j-1]+1)-(4* X[j-1]-2**(5/2))*atan(sqrt(2)* X[j-1]-1))/2**(7/2))/(X[j]-X[j-1])*(10*sin(t))
def F2_right(X, j, t):    
    return ((2* X[j+1]*log(abs(X[j+1]*( X[j+1]+sqrt(2))+1))-2* X[j+1]*log(abs(X[j+1]*( X[j+1]-sqrt(2))+1))+(4* X[j+1]+2**(5/2))*atan(sqrt(2)* X[j+1]+1)+(4* X[j+1]-2**(5/2))*atan(sqrt(2)* X[j+1]-1)-2*(log(abs(X[j]*( X[j]+sqrt(2))+1))-log(abs(X[j]*( X[j]-sqrt(2))+1))+2*(atan(sqrt(2)* X[j]+1)+atan(sqrt(2)* X[j]-1)))* X[j+1]-2**(5/2)*atan(sqrt(2)* X[j]+1)+2**(5/2)*atan(sqrt(2)* X[j]-1))/2**(7/2)) / (X[j+1] - X[j]) *(10*sin(t))
def F3_left(X, j, t):
    return cos(5*t)* (-(2*( X[j]+4)**2*log(X[j]+4)- X[j]*(3* X[j]+4*(( X[j-1]+4)*log(X[j-1]+4)- X[j-1])+8)+2*( X[j-1]-4)*( X[j-1]+4)*log(X[j-1]+4)-( X[j-1]-8)* X[j-1])/4) / (X[j] - X[j-1]) 
def F3_right(X, j, t):
    return  cos(5*t)*((2*( X[j+1]+4)**2*log(X[j+1]+4)- X[j+1]*(3* X[j+1]+4*(( X[j]+4)*log(X[j]+4)- X[j])+8)+2*( X[j]-4)*( X[j]+4)*log(X[j]+4)-( X[j]-8)* X[j])/4)/ (X[j+1] - X[j]) 

# Расчет Fik методом трапеции
def Fk(F_left, F_right, X, j, tau, t, k):
    return tau/2 * (F_left(X, j, t[k]) + F_right(X, j, t[k]) + F_left(X, j, t[k-1]) + F_right(X, j, t[k-1]))

def G(X, j, tau, t, k, Uk, A, B, C, c, p, q):
    if X[j] < 0.3:
        return (c[0]*(X[j] - X[j-1])/6 - tau/2 * A(X, j, p[0], q[0]))*Uk[j-1]+ (c[0]/3 * (X[j+1] - X[j-1]) - tau/2 * B(X, j, p[0], q[0]))*Uk[j]+ (c[0]*(X[j+1] - X[j])/6 - tau/2 * C(X, j, p[0], q[0]))*Uk[j+1] + Fk(F1_left, F1_right, X, j, tau, t, k)
    elif X[j] == 0.3:
        return (c[0]*(X[j] - X[j-1])/6 - tau/2 * A(X, j, p[0], q[0]))*Uk[j-1]+ (c[0]*(X[j]-X[j-1])/3 + c[1]*(X[j+1]-X[j])/3 - tau/2 * (B(X, j, p[0], q[0], 'l') + B(X, j, p[1], q[1], 'r')))*Uk[j]+ (c[1]*(X[j+1] - X[j])/6 - tau/2 * C(X, j, p[1], q[1]))*Uk[j+1] + Fk(F1_left, F2_right, X, j, tau, t, k)
    elif (X[j] > 0.3)&(X[j] < 0.8):
        return (c[1]*(X[j] - X[j-1])/6 - tau/2 * A(X, j, p[1], q[1]))*Uk[j-1]+ (c[1]/3 * (X[j+1] - X[j-1]) - tau/2 * B(X, j, p[1], q[1]))*Uk[j]+ (c[1]*(X[j+1] - X[j])/6 - tau/2 * C(X, j, p[1], q[1]))*Uk[j+1] + Fk(F2_left, F2_right, X, j, tau, t, k)
    elif X[j] == 0.8:
        return (c[1]*(X[j] - X[j-1])/6 - tau/2 * A(X, j, p[1], q[1]))*Uk[j-1]+ (c[1]*(X[j]-X[j-1])/3 + c[2]*(X[j+1]-X[j])/3 - tau/2 * (B(X, j, p[1], q[1], 'l') + B(X, j, p[2], q[2], 'r')))*Uk[j]+ (c[2]*(X[j+1] - X[j])/6 - tau/2 * C(X, j, p[2], q[2]))*Uk[j+1] + Fk(F2_left, F3_right, X, j, tau, t, k)
    else:
        return (c[2]*(X[j] - X[j-1])/6 - tau/2 * A(X, j, p[2], q[2]))*Uk[j-1]+ (c[2]/3 * (X[j+1] - X[j-1]) - tau/2 * B(X, j, p[2], q[2]))*Uk[j]+ (c[2]*(X[j+1] - X[j])/6 - tau/2 * C(X, j, p[2], q[2]))*Uk[j+1] + Fk(F3_left, F3_right, X, j, tau, t, k)
        
def Ua(t):
    return math.exp(-t)

def Ub(t):
    return 1 - math.exp(-t)

# это прошлая лаба
def get_zero_level(X, n, A, B, C, Ua=1):
    
    Ub = 1
    Bo = 1
    Co = 0
    fo = Ua             
    B_starter = 1
    A_starter = 0
    f_starter = Ub      

    alpha_0 = -Co / Bo
    beta_0 = fo / Bo
    alpha = np.array([alpha_0])
    beta = np.array([beta_0])
    
    for j in range(1, n-1):
        if X[j] < 0.3:
            Ac = A(X, j, p[0], q[0])
            Bc = B(X, j, p[0], q[0])
            Cc = C(X, j, p[0], q[0])
        elif X[j] == 0.3:
            Ac = A(X, j, p[0], q[0])
            Bc = B(X, j, p[0], q[0], 'l') + B(X, j, p[1], q[1], 'r')
            Cc = C(X, j, p[1], q[1])
        elif (X[j] > 0.3)&(X[j] < 0.8):
            Ac = A(X, j, p[1], q[1])
            Bc = B(X, j, p[1], q[1])
            Cc = C(X, j, p[1], q[1])
        elif X[j] == 0.8:
            Ac = A(X, j, p[1], q[1])
            Bc = B(X, j, p[1], q[1], 'l') + B(X, j, p[2], q[2], 'r')
            Cc = C(X, j, p[2], q[2])
        else:
            Ac = A(X, j, p[2], q[2])
            Bc = B(X, j, p[2], q[2])
            Cc = C(X, j, p[2], q[2])
        alpha = np.append(alpha, -Cc / (Ac * alpha[j - 1] + Bc))

    for j in range(1, n-1):
        if X[j] < 0.3:
            Ac = A(X, j, p[0], q[0])
            Bc = B(X, j, p[0], q[0])
            f =  F11_right(X, j)
        elif X[j] == 0.3:
            Ac = A(X, j, p[0], q[0])
            Bc = B(X, j, p[0], q[0], 'l') + B(X, j, p[1], q[1], 'r')
            f = F11_left(X, j)+F22_right(X, j)
        elif (X[j] > 0.3)&(X[j] < 0.8):
            Ac = A(X, j, p[1], q[1])
            Bc = B(X, j, p[1], q[1])
            f = F22_left(X, j) + F22_right(X, j)
        elif X[j] == 0.8:
            Ac = A(X, j, p[1], q[1])
            Bc = B(X, j, p[1], q[1], 'l') + B(X, j, p[2], q[2], 'r')
            f = F22_left(X, j) + F33_right(X, j)
        else:
            Ac = A(X, j, p[2], q[2])
            Bc = B(X, j, p[2], q[2])
            f = F33_left(X, j) + F33_right(X, j)
        beta = np.append(beta, (f - Ac * beta[j - 1]) / (Ac * alpha[j - 1] + Bc))

    U_starter = (f_starter - A_starter * beta[n - 2]) / (A_starter * alpha[n - 2] + B_starter)
    U = np.array([U_starter])

    for i in range(n, 1, -1):
        U = np.append(U, alpha[i - 2] * U[n - i] + beta[i - 2])

    return U[::-1]

# Это прогонка для актуальной лабы
def RunThrough(X, n, tau, Ua, Ub, A, B, C, c, p, q, Uk, k, t):
    
    Bo = 1
    Co = 0
    fo = Ua                         
    B_starter = 1
    A_starter = 0   
    f_starter = 1            

    alpha_0 = -Co / Bo
    beta_0 = fo / Bo
    alpha = np.array([alpha_0])
    beta = np.array([beta_0])
    
    for j in range(1, n-1):
        if X[j] < 0.3:
            Ac = A1(A, X, j, tau, c[0], p[0], q[0])
            Bc = A2(B, X, j, tau, c[0], p[0], q[0])
            Cc = A3(C, X, j, tau, c[0], p[0], q[0])
        elif X[j] == 0.3:
            Ac = A1(A, X, j, tau, c[0], p[0], q[0])
            Bc = A2(B, X, j, tau, c[0], p[0], q[0], 'l') + A2(B, X, j, tau, c[1], p[1], q[1], 'r')
            Cc = A3(C, X, j, tau, c[1], p[1], q[1])
        elif (X[j] > 0.3)&(X[j] < 0.8):
            Ac = A1(A, X, j, tau, c[1], p[1], q[1])
            Bc = A2(B, X, j, tau, c[1], p[1], q[1])
            Cc = A3(C, X, j, tau, c[1], p[1], q[1])
        elif X[j] == 0.8:
            Ac = A1(A, X, j, tau, c[1], p[1], q[1])
            Bc = A2(B, X, j, tau, c[1], p[1], q[1], 'l') + A2(B, X, j, tau, c[2], p[2], q[2], 'r')
            Cc = A3(C, X, j, tau, c[2], p[2], q[2])
        else:
            Ac = A1(A, X, j, tau, c[2], p[2], q[2])
            Bc = A2(B, X, j, tau, c[2], p[2], q[2])
            Cc = A3(C, X, j, tau, c[2], p[2], q[2])
        alpha = np.append(alpha, -Cc / (Ac * alpha[j - 1] + Bc))

    for j in range(1, n-1):
        if X[j] < 0.3:
            Ac = A1(A, X, j, tau, c[0], p[0], q[0])
            Bc = A2(B, X, j, tau, c[0], p[0], q[0])
            
        elif X[j] == 0.3:
            Ac = A1(A, X, j, tau, c[0], p[0], q[0])
            Bc = A2(B, X, j, tau, c[0], p[0], q[0], 'l') + A2(B, X, j, tau, c[1], p[1], q[1], 'r')
            
        elif (X[j] > 0.3)&(X[j] < 0.8):
            Ac = A1(A, X, j, tau, c[1], p[1], q[1])
            Bc = A2(B, X, j, tau, c[1], p[1], q[1])
            
        elif X[j] == 0.8:
            Ac = A1(A, X, j, tau, c[1], p[1], q[1])
            Bc = A2(B, X, j, tau, c[1], p[1], q[1], 'l') + A2(B, X, j, tau, c[2], p[2], q[2], 'r')
            
        else:
            Ac = A1(A, X, j, tau, c[2], p[2], q[2])
            Bc = A2(B, X, j, tau, c[2], p[2], q[2])
        
        f = G(X, j, tau, t, k, Uk, A, B, C, c, p, q)
        beta = np.append(beta, (f - Ac * beta[j - 1]) / (Ac * alpha[j - 1] + Bc))

    U_starter = (f_starter - A_starter * beta[n - 2]) / (A_starter * alpha[n - 2] + B_starter)
    U = np.array([U_starter])

    for i in range(n, 1, -1):
        U = np.append(U, alpha[i - 2] * U[n - i] + beta[i - 2])  #добавляет значения вдоль указанной оси в конец массива//массив, значения,

    return U[::-1]


# Это сама лаба
def Scheme(h, N, section, l=0, r=1.2, T=3):
    
    tau = T/N
    t = np.arange(0, T, tau)                 #для создания списка последовательных чисел
    t = np.append(t, T)
    t = np.append(t, T+tau)
    
    X = np.array([])
    ai = (0, 0.3, 0.8, 1.2)
    for i in range(3):
        if i != 2:
            n = (ai[i+1]-ai[i])/h
            if int(n) != int(n+0.1):
                n = math.ceil(n)        #Функция ceil() возвращает предельное значение х, т.е. наименьшее целое число не меньше, чем х
            else:
                n = math.floor(n)        #Функция floor() возвращает floor х т.е. наибольшее целое число, не большее, чем х.
            X = np.concatenate((X, np.linspace(ai[i], ai[i+1], n, endpoint=False)))
        else:
            n = (ai[i+1]-ai[i])/h
            if int(n) != int(n+0.1):
                n = math.ceil(n)
            else:
                n = math.floor(n)
            X = np.concatenate((X, np.linspace(ai[i], ai[i+1], n+1, endpoint=True)))  # объединить массивы
    n = len(X)
    
    Uk = []
    Uk.append(get_zero_level(X, n, A, B, C))

    for k in range(1, N+1):
        fo = Ua(t[k])
        f_starter = Ub(t[k])
        Uk.append(RunThrough(X, n, tau, fo, f_starter, A, B, C, c, p, q, Uk[k-1], k, t))
            
    print(len(X), len(Uk))
    
    return X, Uk[int(section*N)]


def painter():    
    fig, ax = plt.subplots(nrows=2, ncols=2)
    ax1, ax2, ax3, ax4 = ax.flatten()

    ax1.plot(Scheme(0.1, 12, 0)[0], Scheme(0.1, 12, 0)[1])
    ax1.plot(Scheme(0.05, 24, 0)[0], Scheme(0.05, 24, 0)[1])
    ax1.plot(Scheme(0.01, 120, 0)[0], Scheme(0.01, 120, 0)[1])
    ax1.axis([0, 1.2, -1, 3])
    ax1.set_title('t = 0')
    ax1.legend(loc='upper left', labels=['M=12, N=12', 'M=24, N=24', 'M=120, N=120'])
    ax1.grid()
    
    ax2.plot(Scheme(0.1, 12, 0.25)[0], Scheme(0.1, 12, 0.25)[1])
    ax2.plot(Scheme(0.05, 24, 0.25)[0], Scheme(0.05, 24, 0.25)[1])
    ax2.plot(Scheme(0.01, 120, 0.25)[0], Scheme(0.01, 120, 0.25)[1])
    ax2.axis([0, 1.2, -1, 3])
    ax2.set_title('t = T/4')
    ax2.legend(loc='upper left', labels=['M=12, N=12', 'M=24, N=24', 'M=120, N=120'])
    ax2.grid()
    
    ax3.plot(Scheme(0.1, 12, 0.5)[0], Scheme(0.1, 12, 0.5)[1])
    ax3.plot(Scheme(0.05, 24, 0.5)[0], Scheme(0.05, 24, 0.5)[1])
    ax3.plot(Scheme(0.01, 120, 0.5)[0], Scheme(0.01, 120, 0.5)[1])
    ax3.axis([0, 1.2, -1, 3])
    ax3.set_title('t = T/2')
    ax3.legend(loc='upper left', labels=['M=12, N=12', 'M=24, N=24', 'M=120, N=120'])
    ax3.grid()
    
    ax4.plot(Scheme(0.1, 12, 1)[0], Scheme(0.1, 12, 1)[1])
    ax4.plot(Scheme(0.05, 24, 1)[0], Scheme(0.05, 24, 1)[1])
    ax4.plot(Scheme(0.01, 120, 1)[0], Scheme(0.01, 120, 1)[1])
    ax4.axis([0, 1.2, -1, 3])
    ax4.set_title('t = T')
    ax4.legend(loc='upper left', labels=['M=12, N=12', 'M=24, N=24', 'M=120, N=120'])
    ax4.grid()
    
    fig.set_size_inches(16, 12)
    plt.subplots_adjust(wspace=0.4, hspace=0.4)

painter()

# Это потоки
def make_dU(X, U, h):
    dU = np.array([])
    for i in range(U.size-1):
        if X[i] < 0.3:
            dU = np.append(dU, -p[0]*(U[i+1]-U[i])/h)
        elif (X[i] >= 0.3)&(X[i] < 0.8):
            dU = np.append(dU, -p[1]*(U[i+1]-U[i])/h)
        else:
            dU = np.append(dU, -p[2]*(U[i+1]-U[i])/h)
    return dU

# Это функция рисования потоков
def flow_chart(ax, level, wh, section):
    
    X1, U1 = Scheme(0.005, 12, level)
    X2, U2 = Scheme(0.05, 24, level)
    X3, U3 = Scheme(0.01, 120, level)
    
    ax.hlines(make_dU(X1, U1, 0.005), np.arange(X1[0], X1[X1.size-1], 0.005), np.arange(X1[1], X1[X1.size-1]+0.005, 0.005))
    ax.hlines(make_dU(X2, U2, 0.05), np.arange(X2[0], X2[X2.size-1], 0.05), np.arange(X2[1], X2[X2.size-1]+0.05, 0.05), colors='r')
    ax.hlines(make_dU(X3, U3, 0.01), np.arange(X3[0], X3[X3.size-1], 0.01), np.arange(X3[1], X3[X3.size-1]+0.01, 0.01), colors='#15B01A')
    ax.set_title(f't = {section}')
    ax.legend(loc=(0,1), labels=['M=12, N=12', 'M=24, N=24', 'M=120, N=120'])
    ax.grid()



fig, ax = plt.subplots(nrows=2, ncols=2)
ax1, ax2, ax3, ax4 = ax.flatten()

flow_chart(ax1, 0, 'upper left', '0')
flow_chart(ax2, 0.25, 'upper left', 'T/4')
flow_chart(ax3, 0.5, 'upper right', 'T/2')
flow_chart(ax4, 1, 'lower left', 'T')

fig.set_size_inches(16, 12)
plt.subplots_adjust(wspace=0.4, hspace=0.4)